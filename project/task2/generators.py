from typing import Callable, Iterator, TypeVar, Iterable, Optional, Any, List, Tuple
from functools import reduce, partial

T = TypeVar("T")
U = TypeVar("U")
V = TypeVar("V")


def make_data_generator(
    data: Iterable[T],
) -> Iterator[T]:  # CORRECTIONS: implemented a generator
    """
    Creates a generator based on an iterable object.

    Parameters:
        data : Iterable[Any] (Input iterable object such as list, range, tuple, etc.)

    Returns:
        Generator[Any, None, None]: Generator yielding elements one-by-one from the given iterable.
    """
    iterator = iter(data)

    try:
        while True:
            item = next(iterator)
            yield item
    except StopIteration:
        return


def compose_steps(
    source: Iterable[Any],
    transformations: List[Callable[[Iterable[Any]], Any]],
) -> Any:  # CORRECTIONS: compose_steps gets source:Iterable[Any], turns it into an iterator iter(source), and applies transformations sequentially.
    """
    Composes transformation steps sequentially applied to the data source.

    Parameters:
        source : Generator[T, None, None] (Source data generator)
        transformations : List[Callable[[Generator[T, None, None]], Generator[U, None, None]]] (List of transformation functions)

    Returns:
        Generator[U, None, None]: Resulting generator after applying all transformations.
    """
    stream: Any = iter(source)
    for transform in transformations:
        stream = transform(stream)
    return stream  # CORRECTIONS: Returns Any (it can be either an iterator or a reduce result).


def aggregate_results(
    stream: Iterable[V], accumulator: Callable[[Iterable[V]], U]
) -> U:
    """
    Aggregates the results produced by the generator into a single value.

    Parameters:
        generator : Generator[V, None, None] (Generator producing values)
        accumulator : Callable[[Iterable[V]], U] (Function that collects the output)

    Returns:
        U: Final aggregated result collected via the provided accumulator.
    """
    return accumulator(stream)


def apply_map(
    transform: Callable[[T], V]
) -> Callable[
    [Iterable[T]], Iterator[V]
]:  # CORRECTIONS: apply_map uses the built-in map.
    """
    Applies a mapping transformation to each element of the generator.

    Parameters:
        transform : Callable[[T], V] (Transformation function)

    Returns:
        Callable[[Generator[T, None, None]], Generator[V, None, None]]: Function wrapping the transformation logic.
    """
    return partial(
        map, transform
    )  # CORRECTIONS: Replaced lambda gen: map(transform, gen) with partial(map, transform)


def apply_filter(
    predicate: Callable[[T], bool]
) -> Callable[
    [Iterable[T]], Iterator[T]
]:  # CORRECTIONS: apply_filter uses the built-in filter.
    """
    Filters out elements from the generator based on a condition.

    Parameters:
        predicate : Callable[[T], bool] (Predicate function determining whether to keep an element)

    Returns:
        Callable[[Generator[T, None, None]], Generator[T, None, None]]: Filtered generator function.
    """
    return partial(
        filter, predicate
    )  # CORRECTIONS: Replaced lambda gen: filter(predicate, gen) with partial(filter, predicate)


def apply_reduce(
    reduction: Callable[[Optional[V], T], V], initial: Optional[V] = None
) -> Callable[
    [Iterable[T]], Optional[V]
]:  # CORRECTIONS: apply_reduce uses functiontools.reduce and returns Optional[V] (if initial can be None).
    """
    Reduces the sequence of values generated by reducing them into a single result.

    Parameters:
        reduction : Callable[[Optional[V], T], V] (Reduction function combining elements)
        initial : Optional[V] (Initial value for reduction)

    Returns:
        Callable[[Generator[T, None, None]], V]: Reduction function wrapper.
    """
    return lambda gen: reduce(reduction, gen, initial)


def apply_zip(
    other_gen: Iterable[U],
) -> Callable[
    [Iterable[T]], Iterator[Tuple[T, U]]
]:  # CORRECTIONS: apply_zip uses the built-in zip.
    """
    Zips together two generators creating pairs of corresponding elements.

    Parameters:
        other_gen : Generator[U, None, None] (Second generator to combine with)

    Returns:
        Callable[[Generator[T, None, None]], Generator[Tuple[T, U], None, None]]: Zipped generator function.
    """
    return partial(
        zip, other_gen
    )  # CORRECTIONS: Replaced lambda gen: zip(gen, other_gen) with partial(zip, other_gen)
